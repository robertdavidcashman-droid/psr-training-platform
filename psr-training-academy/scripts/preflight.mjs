#!/usr/bin/env node

/**
 * Preflight health check script
 * Checks environment, database, auth, and Supabase connectivity
 */

import { readFileSync, existsSync, writeFileSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');

const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function loadEnv() {
  const envPath = join(projectRoot, '.env.local');
  const envExamplePath = join(projectRoot, 'env.example');
  
  const env = {};
  
  if (existsSync(envPath)) {
    const content = readFileSync(envPath, 'utf-8');
    content.split('\n').forEach(line => {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key) {
          env[key.trim()] = valueParts.join('=').trim();
        }
      }
    });
  }
  
  // Also check process.env (for runtime)
  Object.keys(process.env).forEach(key => {
    if (key.startsWith('NEXT_PUBLIC_') || key.startsWith('SUPABASE_')) {
      env[key] = process.env[key];
    }
  });
  
  return env;
}

async function checkHealthEndpoint(baseUrl = 'http://localhost:3000') {
  try {
    const response = await fetch(`${baseUrl}/api/health`, {
      signal: AbortSignal.timeout(10000),
    });
    
    if (!response.ok) {
      return { ok: false, error: `HTTP ${response.status}` };
    }
    
    const data = await response.json();
    return { ok: data.status === 'ok', data };
  } catch (err) {
    return { ok: false, error: err.message };
  }
}

async function checkDiagnosticsEndpoint(baseUrl = 'http://localhost:3000') {
  try {
    const response = await fetch(`${baseUrl}/api/diagnostics/supabase`, {
      signal: AbortSignal.timeout(10000),
    });
    
    if (!response.ok) {
      return { ok: false, error: `HTTP ${response.status}` };
    }
    
    const data = await response.json();
    return { ok: data.status === 'ok', data };
  } catch (err) {
    return { ok: false, error: err.message };
  }
}

function checkSupabaseCli() {
  try {
    const { execSync } = require('child_process');
    execSync('supabase --version', { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

function checkLocalSupabase() {
  try {
    const { execSync } = require('child_process');
    const output = execSync('supabase status', { encoding: 'utf-8', stdio: 'pipe' });
    return output.includes('API URL:');
  } catch {
    return false;
  }
}

async function bootstrapLocalSupabase() {
  log('Attempting to bootstrap local Supabase...', 'cyan');
  
  try {
    const { execSync } = require('child_process');
    const { spawn } = require('child_process');
    
    // Check if supabase is initialized
    const configPath = join(projectRoot, 'supabase', 'config.toml');
    if (!existsSync(configPath)) {
      log('Initializing Supabase...', 'yellow');
      execSync('supabase init', { cwd: projectRoot, stdio: 'inherit' });
    }
    
    // Start Supabase
    log('Starting local Supabase (this may take a minute)...', 'yellow');
    const startProcess = spawn('supabase', ['start'], {
      cwd: projectRoot,
      stdio: 'inherit',
      shell: true,
    });
    
    await new Promise((resolve, reject) => {
      startProcess.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`supabase start exited with code ${code}`));
        }
      });
    });
    
    // Get local Supabase URLs
    const statusOutput = execSync('supabase status', { encoding: 'utf-8', cwd: projectRoot });
    const apiUrlMatch = statusOutput.match(/API URL:\s*(https?:\/\/[^\s]+)/);
    const anonKeyMatch = statusOutput.match(/anon key:\s*([^\s]+)/);
    
    if (apiUrlMatch && anonKeyMatch) {
      const apiUrl = apiUrlMatch[1];
      const anonKey = anonKeyMatch[1];
      
      // Write to .env.local
      const envPath = join(projectRoot, '.env.local');
      const envContent = `# Auto-generated by preflight
NEXT_PUBLIC_SUPABASE_URL=${apiUrl}
NEXT_PUBLIC_SUPABASE_ANON_KEY=${anonKey}
NEXT_PUBLIC_SITE_URL=http://localhost:3000
`;
      writeFileSync(envPath, envContent);
      log(`âœ“ Local Supabase configured. Environment variables written to .env.local`, 'green');
      
      return { apiUrl, anonKey };
    }
    
    throw new Error('Could not parse Supabase status output');
  } catch (err) {
    log(`âœ— Failed to bootstrap local Supabase: ${err.message}`, 'red');
    return null;
  }
}

async function main() {
  log('\nðŸ” Running Preflight Health Checks...\n', 'cyan');
  
  const env = loadEnv();
  const issues = [];
  const warnings = [];
  
  // Check environment variables
  log('Checking environment variables...', 'cyan');
  const supabaseUrl = env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  const serviceRoleKey = env.SUPABASE_SERVICE_ROLE_KEY;
  
  if (!supabaseUrl || !supabaseUrl.trim()) {
    issues.push('NEXT_PUBLIC_SUPABASE_URL is missing');
    log('  âœ— NEXT_PUBLIC_SUPABASE_URL missing', 'red');
  } else {
    log('  âœ“ NEXT_PUBLIC_SUPABASE_URL set', 'green');
  }
  
  if (!supabaseAnonKey || !supabaseAnonKey.trim()) {
    issues.push('NEXT_PUBLIC_SUPABASE_ANON_KEY is missing');
    log('  âœ— NEXT_PUBLIC_SUPABASE_ANON_KEY missing', 'red');
  } else {
    log('  âœ“ NEXT_PUBLIC_SUPABASE_ANON_KEY set', 'green');
  }
  
  if (!serviceRoleKey) {
    warnings.push('SUPABASE_SERVICE_ROLE_KEY not set (optional, needed for admin operations)');
    log('  âš  SUPABASE_SERVICE_ROLE_KEY not set (optional)', 'yellow');
  } else {
    log('  âœ“ SUPABASE_SERVICE_ROLE_KEY set', 'green');
  }
  
  // Check if we should try local Supabase
  if (issues.length > 0) {
    log('\nChecking for local Supabase fallback...', 'cyan');
    const hasCli = checkSupabaseCli();
    
    if (hasCli) {
      log('  âœ“ Supabase CLI installed', 'green');
      const isLocalRunning = checkLocalSupabase();
      
      if (isLocalRunning) {
        log('  âœ“ Local Supabase is running', 'green');
        // Try to get local URLs
        try {
          const { execSync } = require('child_process');
          const statusOutput = execSync('supabase status', { encoding: 'utf-8', cwd: projectRoot });
          const apiUrlMatch = statusOutput.match(/API URL:\s*(https?:\/\/[^\s]+)/);
          const anonKeyMatch = statusOutput.match(/anon key:\s*([^\s]+)/);
          
          if (apiUrlMatch && anonKeyMatch) {
            log('  âœ“ Found local Supabase URLs', 'green');
            // Update env for this run
            env.NEXT_PUBLIC_SUPABASE_URL = apiUrlMatch[1];
            env.NEXT_PUBLIC_SUPABASE_ANON_KEY = anonKeyMatch[1];
            issues.length = 0; // Clear issues since we have local fallback
          }
        } catch (err) {
          log(`  âœ— Could not get local Supabase status: ${err.message}`, 'red');
        }
      } else {
        log('  âš  Local Supabase not running', 'yellow');
        log('  Attempting to start local Supabase...', 'cyan');
        const localConfig = await bootstrapLocalSupabase();
        if (localConfig) {
          env.NEXT_PUBLIC_SUPABASE_URL = localConfig.apiUrl;
          env.NEXT_PUBLIC_SUPABASE_ANON_KEY = localConfig.anonKey;
          issues.length = 0;
        } else {
          issues.push('Could not bootstrap local Supabase');
        }
      }
    } else {
      log('  âœ— Supabase CLI not installed', 'red');
      warnings.push('Install Supabase CLI for local development: npm install -g supabase');
    }
  }
  
  // Check if app is running
  log('\nChecking application health endpoints...', 'cyan');
  let healthCheck = await checkHealthEndpoint();
  
  if (!healthCheck.ok && healthCheck.error?.includes('fetch')) {
    log('  âš  App not running or unreachable', 'yellow');
    log('  Start the app with: npm run dev', 'yellow');
    warnings.push('Application not running - start with `npm run dev`');
  } else if (healthCheck.ok) {
    log('  âœ“ /api/health endpoint reachable', 'green');
    if (healthCheck.data) {
      const { status, checks } = healthCheck.data;
      if (status === 'ok') {
        log('  âœ“ Health status: OK', 'green');
      } else {
        log(`  âš  Health status: ${status}`, 'yellow');
        if (healthCheck.data.actionable_error) {
          log(`    ${healthCheck.data.actionable_error}`, 'yellow');
        }
      }
      
      if (!checks.db.reachable) {
        // Missing tables is expected before migrations are run - treat as warning, not error
        const dbError = checks.db.error || 'Unknown error';
        if (dbError.includes('does not exist') || dbError.includes('schema cache') || dbError.includes('table')) {
          warnings.push(`Database tables missing - run migrations: ${dbError}`);
          log(`  âš  Database tables missing (expected before migrations): ${dbError.substring(0, 60)}...`, 'yellow');
        } else {
          warnings.push(`Database not reachable: ${dbError} - may need to run migrations`);
          log(`  âš  Database: ${dbError}`, 'yellow');
        }
      } else {
        log('  âœ“ Database reachable', 'green');
      }
      
      if (checks.db.rlsBlocked) {
        warnings.push('Database queries blocked by RLS - may need to run migrations');
        log('  âš  RLS may be blocking queries', 'yellow');
      }
    }
  } else {
    warnings.push(`Health check failed: ${healthCheck.error}`);
    log(`  âš  Health check failed: ${healthCheck.error}`, 'yellow');
  }
  
  // Check diagnostics
  const diagnosticsCheck = await checkDiagnosticsEndpoint();
  if (diagnosticsCheck.ok && diagnosticsCheck.data) {
    log('  âœ“ Diagnostics endpoint OK', 'green');
    if (diagnosticsCheck.data.likelyCauses?.length > 0) {
      diagnosticsCheck.data.likelyCauses.forEach(cause => {
        if (cause.confidence === 'high') {
          issues.push(`${cause.cause}: ${cause.fix}`);
        } else {
          warnings.push(`${cause.cause}: ${cause.fix}`);
        }
      });
    }
  }
  
  // Summary
  log('\n' + '='.repeat(50), 'cyan');
  if (issues.length === 0) {
    if (warnings.length === 0) {
      log('âœ“ PREFLIGHT PASSED', 'green');
      process.exit(0);
    } else {
      // Only warnings - this is OK, migrations may not be run yet
      log('âš  PREFLIGHT PASSED (with warnings)', 'yellow');
      log('\nWarnings:', 'yellow');
      warnings.forEach(warning => log(`  â€¢ ${warning}`, 'yellow'));
      log('\nðŸ’¡ These are expected if migrations haven\'t been run yet.', 'cyan');
      log('   Run migrations in Supabase SQL Editor to resolve.', 'cyan');
      process.exit(0); // Exit with success if only warnings
    }
  } else {
    log('âœ— PREFLIGHT FAILED', 'red');
    log('\nIssues:', 'red');
    issues.forEach(issue => log(`  â€¢ ${issue}`, 'red'));
    
    if (warnings.length > 0) {
      log('\nWarnings:', 'yellow');
      warnings.forEach(warning => log(`  â€¢ ${warning}`, 'yellow'));
    }
    
    process.exit(1);
  }
}

main().catch(err => {
  log(`\nâœ— Preflight script error: ${err.message}`, 'red');
  console.error(err);
  process.exit(1);
});
