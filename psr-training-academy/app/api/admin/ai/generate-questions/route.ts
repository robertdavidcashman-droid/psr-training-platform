import { NextResponse } from 'next/server';
import { z } from 'zod';
import { requireAdmin } from '@/lib/auth';
import { createClient } from '@/lib/supabase/server';
import { logAuditEvent } from '@/lib/audit';

const schema = z.object({
  prompt: z.string().min(5).max(5000),
  count: z.number().int().min(1).max(10).default(3),
});

export async function POST(request: Request) {
  const user = await requireAdmin();
  const supabase = await createClient();

  const body = await request.json().catch(() => null);
  const parsed = schema.safeParse(body);
  if (!parsed.success) return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });

  // Stubbed generator: deterministic, no external calls.
  const base = parsed.data.prompt.trim();
  const n = parsed.data.count;

  const suggestions = Array.from({ length: n }).map((_, i) => ({
    type: 'mcq' as const,
    difficulty: 2,
    prompt: `${base}\n\n(Generated draft #${i + 1})`,
    explanation: 'Draft generated by stub. Replace with a real explanation and publish when reviewed.',
    options: [
      { label: 'A', text: 'Option A (placeholder)', is_correct: false },
      { label: 'B', text: 'Option B (placeholder)', is_correct: true },
      { label: 'C', text: 'Option C (placeholder)', is_correct: false },
      { label: 'D', text: 'Option D (placeholder)', is_correct: false },
    ],
  }));

  await logAuditEvent(supabase, user.id, {
    action: 'ai_generate',
    entity: 'questions',
    entityId: null,
    metadata: { provider: 'stub', count: n },
  });

  return NextResponse.json({ provider: 'stub', suggestions });
}
